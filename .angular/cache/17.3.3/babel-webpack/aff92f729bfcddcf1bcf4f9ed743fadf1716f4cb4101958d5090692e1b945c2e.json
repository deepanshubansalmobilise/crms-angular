{"ast":null,"code":"import _asyncToGenerator from \"D:/anarish/crms-angular-template/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { inject, ElementRef, Directive, InjectionToken, signal, NgZone, Injector, input, booleanAttribute, numberAttribute, computed, EventEmitter, runInInjectionContext, effect, Input, Output, PLATFORM_ID, Injectable, ContentChild, Component, ChangeDetectionStrategy, ViewChild, Renderer2, ApplicationRef, createComponent, NgModule } from '@angular/core';\nimport { Observable, throttleTime, tap, map, fromEvent, switchMap, of, takeUntil, merge, startWith, delay, EMPTY, takeWhile, interval, animationFrameScheduler } from 'rxjs';\nimport { Platform } from '@angular/cdk/platform';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { SmoothScrollManager } from 'ngx-scrollbar/smooth-scroll';\nimport { fromPromise } from 'rxjs/internal/observable/innerFrom';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nconst _c0 = [\"scrollbarButton\", \"\"];\nfunction ScrollbarY_Conditional_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"button\", 5)(1, \"button\", 6);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-button \", ctx_r0.cmp.buttonClass, \"\");\n    i0.ɵɵadvance();\n    i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-button \", ctx_r0.cmp.buttonClass, \"\");\n  }\n}\nfunction ScrollbarX_Conditional_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"button\", 5)(1, \"button\", 6);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-button \", ctx_r0.cmp.buttonClass, \"\");\n    i0.ɵɵadvance();\n    i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-button \", ctx_r0.cmp.buttonClass, \"\");\n  }\n}\nconst _c1 = \"[_nghost-%COMP%]{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky[_ngcontent-%COMP%]{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:100;opacity:var(--_scrollbar-hover-opacity);transition:var(--_scrollbar-opacity-transition)}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]{touch-action:none;-webkit-user-select:none;user-select:none;top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);pointer-events:var(--_scrollbar-pointer-events);transition:var(--scrollbar-track-wrapper-transition);position:absolute;overflow:hidden;display:flex;place-items:center}.ng-scrollbar-track[_ngcontent-%COMP%]{position:relative;width:100%;height:100%;background-color:var(--scrollbar-track-color);border-radius:var(--scrollbar-border-radius);cursor:default;z-index:1;order:2}.ng-scrollbar-thumb[_ngcontent-%COMP%]{box-sizing:border-box;position:absolute;transition:var(--scrollbar-thumb-transition);border-radius:var(--scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:_ngcontent-%COMP%_scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes _ngcontent-%COMP%_scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}\";\nfunction Scrollbars_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"scrollbar-y\");\n  }\n}\nfunction Scrollbars_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"scrollbar-x\");\n  }\n}\nconst _c2 = [\"contentWrapper\"];\nconst _c3 = [\"*\"];\nconst _c4 = [\"externalViewport\", \"\"];\nconst _c5 = \"[_nghost-%COMP%]{display:block;position:relative;max-height:100%;max-width:100%;--scrollbar-border-radius: 0px;--scrollbar-thickness: 5;--scrollbar-offset: 0;--scrollbar-track-wrapper-transition: width 60ms linear, height 60ms linear;--scrollbar-track-color: transparent;--scrollbar-thumb-color: rgb(0 0 0 / 20%);--scrollbar-thumb-hover-color: var(--scrollbar-thumb-color);--scrollbar-hover-thickness: var(--scrollbar-thickness);--scrollbar-thumb-transition: none;--scrollbar-thumb-min-size: 20;--scrollbar-button-color: var(--scrollbar-thumb-color);--scrollbar-button-hover-color: var(--scrollbar-button-color);--scrollbar-button-active-color: var(--scrollbar-button-hover-color);--scrollbar-button-fill: white;--scrollbar-button-hover-fill: var(--scrollbar-button-fill);--scrollbar-button-active-fill: var(--scrollbar-button-hover-fill);--scrollbar-hover-opacity-transition-enter-duration: 0;--scrollbar-hover-opacity-transition-leave-duration: .4s;--scrollbar-hover-opacity-transition-leave-delay: 1s;--scrollbar-overscroll-behavior: initial;--scrollbar-mobile-overscroll-behavior: none;--_scrollbar-thickness: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_thumb-x-color: var(--scrollbar-thumb-color);--_thumb-y-color: var(--scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}[_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--dropped-offset: 1px;--dropped-offset-top: var(--dropped-offset);--dropped-offset-bottom: var(--dropped-offset);--dropped-offset-start: var(--dropped-offset);--dropped-offset-end: var(--dropped-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}.ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}.ng-scroll-viewport[_nghost-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior)}.ng-scroll-viewport[_nghost-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport>.ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}.ng-scroll-viewport[_nghost-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{scrollbar-width:none!important}.ng-scroll-viewport[_nghost-%COMP%]::-webkit-scrollbar, .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport::-webkit-scrollbar{display:none!important}[position=invertX][_nghost-%COMP%], [position=invertAll][_nghost-%COMP%]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}[dir=ltr][_nghost-%COMP%]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}[dir=ltr][position=invertY][_nghost-%COMP%], [dir=ltr][position=invertAll][_nghost-%COMP%]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}[dir=rtl][_nghost-%COMP%]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}[dir=rtl][position=invertY][_nghost-%COMP%], [dir=rtl][position=invertAll][_nghost-%COMP%]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}[verticalUsed=true][horizontalUsed=true][_nghost-%COMP%]{--_scrollbar-thickness-margin: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}[horizontalUsed=true][_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}[horizontalUsed=true][position=invertX][_nghost-%COMP%], [horizontalUsed=true][position=invertAll][_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}[verticalUsed=true][dir=ltr][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}[verticalUsed=true][dir=rtl][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}[verticalUsed=true][position=invertY][dir=ltr][_nghost-%COMP%], [verticalUsed=true][position=invertAll][dir=ltr][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}[verticalUsed=true][position=invertY][dir=rtl][_nghost-%COMP%], [verticalUsed=true][position=invertAll][dir=rtl][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}[appearance=native][verticalUsed=true][dir=ltr][_nghost-%COMP%]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][verticalUsed=true][dir=rtl][_nghost-%COMP%]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}[appearance=native][verticalUsed=true][position=invertY][dir=ltr][_nghost-%COMP%], [appearance=native][verticalUsed=true][position=invertAll][dir=ltr][_nghost-%COMP%]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}[appearance=native][verticalUsed=true][position=invertY][dir=rtl][_nghost-%COMP%], [appearance=native][verticalUsed=true][position=invertAll][dir=rtl][_nghost-%COMP%]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][horizontalUsed=true][_nghost-%COMP%]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][horizontalUsed=true][position=invertX][_nghost-%COMP%], [appearance=native][horizontalUsed=true][position=invertAll][_nghost-%COMP%]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}[visibility=hover][_nghost-%COMP%]{--_scrollbar-hover-opacity: 0;--_scrollbar-opacity-transition: opacity var(--scrollbar-hover-opacity-transition-leave-duration) var(--scrollbar-hover-opacity-transition-leave-delay)}[visibility=hover][_nghost-%COMP%]:hover, [visibility=hover][_nghost-%COMP%]:active, [visibility=hover][_nghost-%COMP%]:focus{--_scrollbar-hover-opacity: 1;--_scrollbar-opacity-transition: opacity var(--scrollbar-hover-opacity-transition-enter-duration)}[dir=ltr][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [dir=ltr][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=start]{left:0;right:unset}[dir=ltr][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end], [dir=ltr][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=end]{right:0;left:unset}[dir=rtl][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [dir=rtl][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=start]{right:0;left:unset}[dir=rtl][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end], [dir=rtl][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=end]{left:0;right:unset}[_nghost-%COMP%]     .ng-scroll-reached-wrapper, [_nghost-%COMP%]     .ng-scroll-dropped-wrapper, [_nghost-%COMP%]     .scroll-reached-trigger-element, [_nghost-%COMP%]     .scroll-dropped-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}[_nghost-%COMP%]     .ng-scroll-reached-wrapper, [_nghost-%COMP%]     .ng-scroll-dropped-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}[_nghost-%COMP%]     [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end], [_nghost-%COMP%]     [isHorizontallyScrollable=false] .scroll-dropped-trigger-element[trigger=end]{display:none}[_nghost-%COMP%]     [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom], [_nghost-%COMP%]     [isVerticallyScrollable=false] .scroll-dropped-trigger-element[trigger=bottom]{display:none}[_nghost-%COMP%]     .scroll-reached-trigger-element{background:red}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=top], [_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[_ngcontent-%COMP%]{background:#00f}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=top][_ngcontent-%COMP%], [_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=bottom][_ngcontent-%COMP%]{left:0;right:0}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=start][_ngcontent-%COMP%], [_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=end][_ngcontent-%COMP%]{top:0;bottom:0}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=top][_ngcontent-%COMP%]{top:0;height:var(--dropped-offset-top)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=bottom][_ngcontent-%COMP%]{bottom:0;height:var(--dropped-offset-bottom)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=start][_ngcontent-%COMP%]{width:var(--dropped-offset-start)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=end][_ngcontent-%COMP%]{width:var(--dropped-offset-end)}[verticalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y;--_scrollbar-y-thumb-transform-to-value: calc(var(--track-y-length) - var(--thumb-y-length))}[horizontalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x;--_scrollbar-x-thumb-transform-to-value: calc(var(--track-x-length) - var(--thumb-x-length))}[verticalUsed=true][horizontalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}[orientation=vertical][_nghost-%COMP%]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}[orientation=horizontal][_nghost-%COMP%]{--_viewport-overflow: auto hidden}[disableInteraction=true][_nghost-%COMP%]{--_scrollbar-pointer-events: none}[isVerticallyScrollable=false][_nghost-%COMP%]{--_vertical-thumb-display: none}[isHorizontallyScrollable=false][_nghost-%COMP%]{--_horizontal-thumb-display: none}[dragging=x][_nghost-%COMP%], [dragging=y][_nghost-%COMP%]{--_viewport-user-select: none}[horizontalUsed=true][_nghost-%COMP%]{--thumb-x-length: max(calc(var(--viewport-width) * var(--track-x-length) / var(--content-width)), var(--scrollbar-thumb-min-size))}[verticalUsed=true][_nghost-%COMP%]{--thumb-y-length: max(calc(var(--viewport-height) * var(--track-y-length) / var(--content-height)), var(--scrollbar-thumb-min-size))}[dragging=x][_nghost-%COMP%]{--_track-x-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(--scrollbar-thumb-hover-color)}[dragging=y][_nghost-%COMP%]{--_track-y-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(--scrollbar-thumb-hover-color)}[mobile=true][_nghost-%COMP%]{--_viewport-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior)}\";\nlet ScrollViewport = /*#__PURE__*/(() => {\n  class ScrollViewport {\n    constructor() {\n      this.nativeElement = inject(ElementRef).nativeElement;\n    }\n    static #_ = this.ɵfac = function ScrollViewport_Factory(t) {\n      return new (t || ScrollViewport)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: ScrollViewport,\n      selectors: [[\"\", \"scrollViewport\", \"\"]],\n      standalone: true\n    });\n  }\n  return ScrollViewport;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar ScrollbarUpdateReason = /*#__PURE__*/function (ScrollbarUpdateReason) {\n  ScrollbarUpdateReason[\"AfterInit\"] = \"AfterInit\";\n  ScrollbarUpdateReason[\"Resized\"] = \"ResizeObserver\";\n  return ScrollbarUpdateReason;\n}(ScrollbarUpdateReason || {});\nconst NG_SCROLLBAR_OPTIONS = new InjectionToken('NG_SCROLLBAR_OPTIONS');\nconst NG_SCROLLBAR_POLYFILL = new InjectionToken('NG_SCROLLBAR_POLYFILL');\nfunction resizeObserver({\n  element,\n  contentWrapper,\n  throttleDuration\n}) {\n  // The first time the observer is triggered as soon as the element is observed,\n  // So we need to differentiate the reason of the event fired\n  let reason = ScrollbarUpdateReason.AfterInit;\n  let resizeObserver;\n  const stream = new Observable(observer => {\n    resizeObserver = new ResizeObserver(() => {\n      observer.next(reason);\n      // After first init event, mark the reason to be a resize from now on.\n      reason = ScrollbarUpdateReason.Resized;\n    });\n    resizeObserver.observe(element);\n    // If a content element has a supporting content scrollbars, observe it!\n    if (contentWrapper) {\n      resizeObserver.observe(contentWrapper);\n    }\n    return () => {\n      resizeObserver?.disconnect();\n    };\n  });\n  return throttleDuration ? stream.pipe(throttleTime(throttleDuration, null, {\n    leading: true,\n    trailing: true\n  })) : stream;\n}\nfunction mutationObserver(element, throttleDuration) {\n  let mutationObserver;\n  const stream = new Observable(observer => {\n    mutationObserver = new MutationObserver(() => {\n      observer.next();\n    });\n    mutationObserver.observe(element, {\n      childList: true,\n      subtree: true\n    });\n    return () => {\n      mutationObserver?.disconnect();\n    };\n  });\n  return stream.pipe(throttleTime(throttleDuration, null, {\n    leading: true,\n    trailing: true\n  }));\n}\nfunction preventSelection(doc) {\n  return tap(() => doc.onselectstart = () => false);\n}\nfunction enableSelection(doc) {\n  return tap(() => doc.onselectstart = null);\n}\nfunction stopPropagation() {\n  return tap(e => {\n    // Have to prevent default to avoid unexpected movement whe you grab object beneath scrollbar #476\n    // https://github.com/MurhafSousli/ngx-scrollbar/issues/476\n    e.preventDefault();\n    e.stopPropagation();\n  });\n}\nvar ViewportClasses = /*#__PURE__*/function (ViewportClasses) {\n  ViewportClasses[\"Viewport\"] = \"ng-scroll-viewport\";\n  ViewportClasses[\"Content\"] = \"ng-scroll-content\";\n  return ViewportClasses;\n}(ViewportClasses || {});\nclass ViewportAdapter {\n  constructor() {\n    /*\n     * A signal that indicates when viewport adapter is initialized\n     */\n    this.initialized = signal(false);\n  }\n  /** Viewport clientHeight */\n  get offsetHeight() {\n    return this.nativeElement.offsetHeight;\n  }\n  /** Viewport clientWidth */\n  get offsetWidth() {\n    return this.nativeElement.offsetWidth;\n  }\n  /** Viewport scrollTop */\n  get scrollTop() {\n    return this.nativeElement.scrollTop;\n  }\n  /** Viewport scrollLeft */\n  get scrollLeft() {\n    return this.nativeElement.scrollLeft;\n  }\n  /** Content height, falls back to scroll height */\n  get contentHeight() {\n    return this.contentWrapperElement.offsetHeight;\n  }\n  /** Content width, falls back to scroll height */\n  get contentWidth() {\n    return this.contentWrapperElement.offsetWidth;\n  }\n  /** The horizontal remaining scrollable distance */\n  get scrollMaxX() {\n    return this.contentWidth - this.offsetWidth;\n  }\n  /** The vertical remaining scrollable distance */\n  get scrollMaxY() {\n    return this.contentHeight - this.offsetHeight;\n  }\n  /**\n   * Initialize viewport\n   */\n  init(viewportElement, contentElement, spacerElement) {\n    // Add viewport class\n    viewportElement.classList.add(ViewportClasses.Viewport);\n    this.nativeElement = viewportElement;\n    // Add content wrapper class\n    contentElement.classList.add(ViewportClasses.Content);\n    // When integrating the scrollbar with virtual scroll, the content wrapper will have fake size,\n    // and a spacer element will have the real size\n    // Therefore, if spaceElement is provided, it will be observed instead of the content wrapper\n    if (spacerElement) {\n      // Set relative position on the spacer element to enable the functionality of sticky for the scrollbars\n      spacerElement.style.position = 'relative';\n      this.contentWrapperElement = spacerElement;\n    } else {\n      // If spacer is not provided, set it as the content wrapper\n      this.contentWrapperElement = contentElement;\n    }\n    this.initialized.set(true);\n  }\n  /**\n   * Scroll viewport vertically\n   */\n  scrollYTo(value) {\n    this.nativeElement.scrollTop = value;\n  }\n  /**\n   * Scroll viewport horizontally\n   */\n  scrollXTo(value) {\n    this.nativeElement.scrollLeft = value;\n  }\n}\n\n/**\n * Injection token that can be used to query for a `NgScrollbar`.\n * Used primarily to avoid circular imports.\n */\nconst NG_SCROLLBAR = new InjectionToken('NG_SCROLLBAR');\nconst defaultOptions = {\n  trackClass: '',\n  thumbClass: '',\n  buttonClass: '',\n  orientation: 'auto',\n  appearance: 'native',\n  visibility: 'native',\n  position: 'native',\n  trackScrollDuration: 50,\n  sensorThrottleTime: 0,\n  disableSensor: false,\n  disableInteraction: false,\n  buttons: false\n};\nlet NgScrollbarCore = /*#__PURE__*/(() => {\n  class NgScrollbarCore {\n    constructor() {\n      /** Injected options */\n      this.injectedOptions = inject(NG_SCROLLBAR_OPTIONS, {\n        optional: true\n      });\n      /** Combine injected option with default options */\n      this.options = this.injectedOptions ? {\n        ...defaultOptions,\n        ...this.injectedOptions\n      } : defaultOptions;\n      this.zone = inject(NgZone);\n      this.platform = inject(Platform);\n      this.injector = inject(Injector);\n      /** A flag that indicates if the platform is mobile */\n      this.isMobile = this.platform.IOS || this.platform.ANDROID;\n      this.dir = inject(Directionality);\n      this.smoothScroll = inject(SmoothScrollManager);\n      this.nativeElement = inject(ElementRef).nativeElement;\n      /**\n       * Indicates when scrollbar thumb is being dragged\n       */\n      this.dragging = signal('none');\n      /**\n       * Sets the supported scroll track of the viewport, there are 3 options:\n       *\n       * - `vertical` Use both vertical and horizontal scrollbar\n       * - `horizontal` Use both vertical and horizontal scrollbar\n       * - `auto` Use both vertical and horizontal scrollbar\n       */\n      this.orientation = input(this.options.orientation);\n      /**\n       * When to show the scrollbar, and there are 3 options:\n       *\n       * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar\n       * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering\n       * - `always` Scrollbars are always shown even if the viewport is not scrollable\n       */\n      this.visibility = input(this.options.visibility);\n      /** Show scrollbar buttons */\n      this.buttons = input(this.options.buttons, {\n        transform: booleanAttribute\n      });\n      /** Disables scrollbar interaction like dragging thumb and jumping by track click */\n      this.disableInteraction = input(this.options.disableInteraction, {\n        transform: booleanAttribute\n      });\n      /** Whether ResizeObserver is disabled */\n      this.disableSensor = input(this.options.disableSensor, {\n        transform: booleanAttribute\n      });\n      /** Throttle interval for detecting changes via ResizeObserver */\n      this.sensorThrottleTime = input(this.options.sensorThrottleTime, {\n        transform: numberAttribute\n      });\n      this.viewportDimension = signal({\n        contentHeight: 0,\n        contentWidth: 0,\n        offsetHeight: 0,\n        offsetWidth: 0\n      });\n      this.state = computed(() => {\n        let verticalUsed = false;\n        let horizontalUsed = false;\n        let isVerticallyScrollable = false;\n        let isHorizontallyScrollable = false;\n        const orientation = this.orientation();\n        const visibility = this.visibility();\n        const viewport = this.viewportDimension();\n        // Check if vertical scrollbar should be displayed\n        if (orientation === 'auto' || orientation === 'vertical') {\n          isVerticallyScrollable = viewport.contentHeight > viewport.offsetHeight;\n          verticalUsed = visibility === 'visible' || isVerticallyScrollable;\n        }\n        // Check if horizontal scrollbar should be displayed\n        if (orientation === 'auto' || orientation === 'horizontal') {\n          isHorizontallyScrollable = viewport.contentWidth > viewport.offsetWidth;\n          horizontalUsed = visibility === 'visible' || isHorizontallyScrollable;\n        }\n        return {\n          verticalUsed,\n          horizontalUsed,\n          isVerticallyScrollable,\n          isHorizontallyScrollable\n        };\n      });\n      this.isVerticallyScrollable = computed(() => this.state().isVerticallyScrollable);\n      this.isHorizontallyScrollable = computed(() => this.state().isHorizontallyScrollable);\n      this.verticalUsed = computed(() => this.state().verticalUsed);\n      this.horizontalUsed = computed(() => this.state().horizontalUsed);\n      /** Scroll duration when the scroll track is clicked */\n      this.trackScrollDuration = this.options.trackScrollDuration;\n      /**\n       *  Sets the appearance of the scrollbar, there are 2 options:\n       *\n       * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.\n       * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.\n       */\n      this.appearance = this.options.appearance;\n      /**\n       * Sets the position of each scrollbar, there are 4 options:\n       *\n       * - `native` (Default) Use the default position like in native scrollbar.\n       * - `invertY` Inverts vertical scrollbar position\n       * - `invertX` Inverts Horizontal scrollbar position\n       * - `invertAll` Inverts both scrollbar positions\n       */\n      this.position = this.options.position;\n      /** A class forwarded to the scrollbar track element */\n      this.trackClass = this.options.trackClass;\n      /** A class forwarded to the scrollbar thumb element */\n      this.thumbClass = this.options.thumbClass;\n      /** A class forwarded to the scrollbar button element */\n      this.buttonClass = this.options.thumbClass;\n      /** Steam that emits when scrollbar is initialized */\n      this.afterInit = new EventEmitter();\n      /** Steam that emits when scrollbar is updated */\n      this.afterUpdate = new EventEmitter();\n      /** Viewport adapter instance */\n      this.viewport = new ViewportAdapter();\n    }\n    ngOnInit() {\n      runInInjectionContext(this.injector, () => {\n        // The direction signal cannot be initialized in the constructor\n        // Because it initially returns 'ltr' even if dir.value is 'rtl`\n        this.direction = toSignal(this.dir.change.pipe(map(() => this.dir.value)), {\n          initialValue: this.dir.value\n        });\n        effect(onCleanup => {\n          // Check whether sensor should be enabled\n          if (this.disableSensor()) {\n            // If sensor is disabled update manually\n            this.sizeChangeSub?.unsubscribe();\n          } else {\n            if (this.platform.isBrowser && this.viewport.initialized()) {\n              this.sizeChangeSub?.unsubscribe();\n              this.zone.runOutsideAngular(() => {\n                this.sizeChangeSub = resizeObserver({\n                  element: this.viewport.nativeElement,\n                  contentWrapper: this.viewport.contentWrapperElement,\n                  throttleDuration: this.sensorThrottleTime()\n                }).pipe(tap(reason => this.update(reason))).subscribe();\n              });\n            }\n          }\n          onCleanup(() => this.sizeChangeSub?.unsubscribe());\n        });\n      });\n    }\n    ngAfterViewInit() {\n      // If sensor is disabled, update to evaluate the state\n      if (this.platform.isBrowser && this.disableSensor()) {\n        // In case of 3rd party library, need to wait for content to be rendered\n        requestAnimationFrame(() => {\n          this.update(ScrollbarUpdateReason.AfterInit);\n        });\n      }\n    }\n    /**\n     * Update local state and the internal scrollbar controls\n     */\n    update(reason) {\n      this.updateCSSVariables();\n      this.zone.run(() => {\n        this.viewportDimension.set({\n          contentHeight: this.viewport.contentHeight,\n          contentWidth: this.viewport.contentWidth,\n          offsetHeight: this.viewport.offsetHeight,\n          offsetWidth: this.viewport.offsetWidth\n        });\n        if (reason === ScrollbarUpdateReason.AfterInit) {\n          this.afterInit.emit();\n        } else {\n          this.afterUpdate.emit();\n        }\n      });\n    }\n    /**\n     * Smooth scroll functions\n     */\n    scrollTo(options) {\n      return this.smoothScroll.scrollTo(this.viewport.nativeElement, options);\n    }\n    /**\n     * Scroll to element by reference or selector\n     */\n    scrollToElement(target, options) {\n      return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);\n    }\n    /**\n     * Update Essential CSS variables\n     */\n    updateCSSVariables() {\n      this.nativeElement.style.setProperty('--content-height', `${this.viewport.contentHeight}`);\n      this.nativeElement.style.setProperty('--content-width', `${this.viewport.contentWidth}`);\n      this.nativeElement.style.setProperty('--viewport-height', `${this.viewport.offsetHeight}`);\n      this.nativeElement.style.setProperty('--viewport-width', `${this.viewport.offsetWidth}`);\n    }\n    static #_ = this.ɵfac = function NgScrollbarCore_Factory(t) {\n      return new (t || NgScrollbarCore)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgScrollbarCore,\n      hostVars: 14,\n      hostBindings: function NgScrollbarCore_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"verticalUsed\", ctx.verticalUsed())(\"horizontalUsed\", ctx.horizontalUsed())(\"isVerticallyScrollable\", ctx.isVerticallyScrollable())(\"isHorizontallyScrollable\", ctx.isHorizontallyScrollable())(\"mobile\", ctx.isMobile)(\"dir\", ctx.direction())(\"position\", ctx.position)(\"dragging\", ctx.dragging())(\"appearance\", ctx.appearance)(\"visibility\", ctx.visibility())(\"orientation\", ctx.orientation())(\"disableInteraction\", ctx.disableInteraction());\n          i0.ɵɵclassProp(\"ng-scrollbar\", true);\n        }\n      },\n      inputs: {\n        orientation: [i0.ɵɵInputFlags.SignalBased, \"orientation\"],\n        visibility: [i0.ɵɵInputFlags.SignalBased, \"visibility\"],\n        buttons: [i0.ɵɵInputFlags.SignalBased, \"buttons\"],\n        disableInteraction: [i0.ɵɵInputFlags.SignalBased, \"disableInteraction\"],\n        disableSensor: [i0.ɵɵInputFlags.SignalBased, \"disableSensor\"],\n        sensorThrottleTime: [i0.ɵɵInputFlags.SignalBased, \"sensorThrottleTime\"],\n        trackScrollDuration: [i0.ɵɵInputFlags.HasDecoratorInputTransform, \"trackScrollDuration\", \"trackScrollDuration\", numberAttribute],\n        appearance: \"appearance\",\n        position: \"position\",\n        trackClass: \"trackClass\",\n        thumbClass: \"thumbClass\",\n        buttonClass: \"buttonClass\"\n      },\n      outputs: {\n        afterInit: \"afterInit\",\n        afterUpdate: \"afterUpdate\"\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_SCROLLBAR,\n        useExisting: NgScrollbarCore\n      }]), i0.ɵɵInputTransformsFeature]\n    });\n  }\n  return NgScrollbarCore;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst scrollTimelinePolyfillUrl = 'https://flackr.github.io/scroll-timeline/dist/scroll-timeline.js';\nlet ScrollbarManager = /*#__PURE__*/(() => {\n  class ScrollbarManager {\n    constructor() {\n      this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));\n      this._polyfillUrl = inject(NG_SCROLLBAR_POLYFILL, {\n        optional: true\n      }) || scrollTimelinePolyfillUrl;\n      this.document = inject(DOCUMENT);\n      this.window = this.document.defaultView;\n      this.scrollTimelinePolyfill = signal(null);\n      if (this.isBrowser && (!this.window['ScrollTimeline'] || !CSS.supports('animation-timeline', 'scroll()'))) {\n        this.initPolyfill();\n      }\n    }\n    initPolyfill() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        try {\n          // Create a script element\n          const script = _this.document.createElement('script');\n          script.src = _this._polyfillUrl;\n          // Wait for the script to load\n          yield new Promise((resolve, reject) => {\n            script.onload = resolve;\n            script.onerror = reject;\n            _this.document.head.appendChild(script);\n          });\n          // Once loaded, access and execute the function attached to the window object\n          if (_this.window['ScrollTimeline']) {\n            _this.scrollTimelinePolyfill.set(_this.window['ScrollTimeline']);\n          } else {\n            console.error('[NgScrollbar]: ScrollTimeline is not attached to the window object.');\n          }\n        } catch (error) {\n          console.error('[NgScrollbar]: Error loading ScrollTimeline script:', error);\n        }\n      })();\n    }\n    static #_ = this.ɵfac = function ScrollbarManager_Factory(t) {\n      return new (t || ScrollbarManager)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ScrollbarManager,\n      factory: ScrollbarManager.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ScrollbarManager;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst SCROLLBAR_CONTROL = new InjectionToken('SCROLLBAR_CONTROL');\nlet ScrollbarAdapter = /*#__PURE__*/(() => {\n  class ScrollbarAdapter {\n    constructor() {\n      // Host component reference\n      this.cmp = inject(NG_SCROLLBAR);\n    }\n    static #_ = this.ɵfac = function ScrollbarAdapter_Factory(t) {\n      return new (t || ScrollbarAdapter)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: ScrollbarAdapter\n    });\n  }\n  return ScrollbarAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PointerEventsAdapter = /*#__PURE__*/(() => {\n  class PointerEventsAdapter {\n    constructor() {\n      // Reference to the NgScrollbar component\n      this.cmp = inject(NG_SCROLLBAR);\n      // Reference to the Scrollbar control component\n      this.control = inject(SCROLLBAR_CONTROL);\n      // Reference to the Document element\n      this.document = inject(DOCUMENT);\n      // Reference to angular zone\n      this.zone = inject(NgZone);\n      // The native element of the directive\n      this.nativeElement = inject(ElementRef).nativeElement;\n      effect(onCleanup => {\n        if (this.cmp.disableInteraction()) {\n          this._pointerEventsSub?.unsubscribe();\n        } else {\n          this.zone.runOutsideAngular(() => {\n            this._pointerEventsSub = this.pointerEvents.subscribe();\n          });\n        }\n        onCleanup(() => this._pointerEventsSub?.unsubscribe());\n      });\n    }\n    static #_ = this.ɵfac = function PointerEventsAdapter_Factory(t) {\n      return new (t || PointerEventsAdapter)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: PointerEventsAdapter\n    });\n  }\n  return PointerEventsAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ThumbAdapter = /*#__PURE__*/(() => {\n  class ThumbAdapter extends PointerEventsAdapter {\n    // Returns thumb size\n    get size() {\n      return this.nativeElement[this.control.sizeProperty];\n    }\n    // The maximum space available for scrolling.\n    get trackMax() {\n      return this.track.size - this.size;\n    }\n    /**\n     * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged\n     * This function is called by thumb drag event using viewport or scrollbar pointer events\n     */\n    get pointerEvents() {\n      return fromEvent(this.nativeElement, 'pointerdown').pipe(stopPropagation(), preventSelection(this.document), switchMap(e => {\n        let startTrackMax;\n        let startScrollMax;\n        const dragStart = of(e).pipe(tap(() => {\n          // Capture scrollMax and trackMax once\n          startTrackMax = this.trackMax;\n          startScrollMax = this.control.viewportScrollMax;\n          this.setDragging(this.control.axis);\n        }));\n        const dragging = fromEvent(this.document, 'pointermove').pipe(stopPropagation());\n        const dragEnd = fromEvent(this.document, 'pointerup', {\n          capture: true\n        }).pipe(stopPropagation(), enableSelection(this.document), tap(() => this.setDragging('none')));\n        return dragStart.pipe(map(startEvent => startEvent[this.control.offsetProperty]), switchMap(startOffset => dragging.pipe(map(moveEvent => moveEvent[this.control.clientProperty]),\n        // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).\n        map(moveClient => moveClient - this.track.offset), map(trackRelativeOffset => startScrollMax * (trackRelativeOffset - startOffset) / startTrackMax), tap(scrollPosition => this.control.instantScrollTo(scrollPosition, startScrollMax)), takeUntil(dragEnd))));\n      }));\n    }\n    constructor() {\n      effect(() => {\n        const script = this.manager.scrollTimelinePolyfill();\n        if (script && !this._animation) {\n          this._animation = startPolyfill(script, this.nativeElement, this.cmp.viewport.nativeElement, this.control.axis);\n        }\n      });\n      super();\n      this.manager = inject(ScrollbarManager);\n      this.track = inject(TrackAdapter);\n    }\n    setDragging(value) {\n      this.zone.run(() => this.cmp.dragging.set(value));\n    }\n    static #_ = this.ɵfac = function ThumbAdapter_Factory(t) {\n      return new (t || ThumbAdapter)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: ThumbAdapter,\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return ThumbAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction startPolyfill(ScrollTimeline, element, source, axis) {\n  return element.animate({\n    translate: ['var(--_scrollbar-thumb-transform-from)', 'var(--_scrollbar-thumb-transform-to)']\n  }, {\n    fill: 'both',\n    easing: 'linear',\n    timeline: new ScrollTimeline({\n      source,\n      axis\n    })\n  });\n}\nlet TrackAdapter = /*#__PURE__*/(() => {\n  class TrackAdapter extends PointerEventsAdapter {\n    // Returns viewport client size\n    get viewportSize() {\n      return this.cmp.viewport[this.control.sizeProperty];\n    }\n    // Get track client rect\n    get clientRect() {\n      return this.nativeElement.getBoundingClientRect();\n    }\n    // Scrollbar track offset\n    get offset() {\n      return this.clientRect[this.control.clientRectProperty];\n    }\n    // Scrollbar track length\n    get size() {\n      return this.nativeElement[this.control.sizeProperty];\n    }\n    // Observable for track dragging events\n    get pointerEvents() {\n      // Observable streams for pointer events\n      const pointerDown$ = fromEvent(this.nativeElement, 'pointerdown').pipe(stopPropagation(), preventSelection(this.document));\n      const pointerUp$ = fromEvent(this.document, 'pointerup', {\n        passive: true\n      }).pipe(enableSelection(this.document));\n      const pointerEnter$ = fromEvent(this.nativeElement, 'pointerover', {\n        passive: true\n      }).pipe(\n      // When mouse is out and enters again, must set the current position first\n      tap(e => this.currMousePosition = e[this.control.offsetProperty]), map(() => true));\n      const pointerLeave$ = fromEvent(this.nativeElement, 'pointerout', {\n        passive: true\n      }).pipe(map(() => false));\n      const pointerOver$ = merge(pointerEnter$, pointerLeave$).pipe(startWith(true));\n      // Keep track of current mouse location while dragging\n      const pointerMove$ = fromEvent(this.nativeElement, 'pointermove', {\n        passive: true\n      }).pipe(tap(e => this.currMousePosition = e[this.control.offsetProperty]));\n      return pointerDown$.pipe(switchMap(startEvent => {\n        // Track pointer location while dragging\n        pointerMove$.pipe(takeUntil(pointerUp$)).subscribe();\n        return this.onTrackFirstClick(startEvent).pipe(delay(200), switchMap(() => {\n          // Otherwise, activate pointermove and pointerout events and switch to ongoing scroll calls\n          return pointerOver$.pipe(switchMap(over => {\n            const currDirection = this.getScrollDirection(this.currMousePosition);\n            const sameDirection = this.scrollDirection === currDirection;\n            // If mouse is out the track pause the scroll calls, otherwise keep going\n            return over && sameDirection ? this.onTrackOngoingMousedown() : EMPTY;\n          }));\n        }), takeUntil(pointerUp$));\n      }));\n    }\n    constructor() {\n      effect(onCleanup => {\n        if (this.cmp.disableSensor()) {\n          this.update();\n          this.sizeChangeSub?.unsubscribe();\n        } else {\n          this.zone.runOutsideAngular(() => {\n            // Update styles with real track size\n            this.sizeChangeSub = resizeObserver({\n              element: this.nativeElement,\n              throttleDuration: this.cmp.sensorThrottleTime()\n            }).pipe(tap(() => this.update())).subscribe();\n          });\n        }\n        onCleanup(() => this.sizeChangeSub?.unsubscribe());\n      });\n      super();\n    }\n    update() {\n      this.cmp.nativeElement.style.setProperty(this.cssLengthProperty, `${this.size}`);\n    }\n    /**\n     *  Callback when mouse is first clicked on the track\n     */\n    onTrackFirstClick(e) {\n      // Initialize variables and determine scroll direction\n      this.currMousePosition = e[this.control.offsetProperty];\n      this.scrollDirection = this.getScrollDirection(this.currMousePosition);\n      this.scrollMax = this.control.viewportScrollMax;\n      return this.scrollTo(this.nextStep());\n    }\n    nextStep() {\n      // Check which direction should the scroll go (forward or backward)\n      if (this.scrollDirection === 'forward') {\n        // Scroll forward\n        const scrollForwardIncrement = this.getScrollForwardStep();\n        // Check if the incremental position is bigger than the scroll max\n        if (scrollForwardIncrement >= this.scrollMax) {\n          return this.scrollMax;\n        }\n        return scrollForwardIncrement;\n      }\n      // Scroll backward\n      const scrollBackwardIncrement = this.getScrollBackwardStep();\n      if (scrollBackwardIncrement <= 0) {\n        return 0;\n      }\n      return scrollBackwardIncrement;\n    }\n    /**\n     * Callback when mouse is still down on the track\n     * Incrementally scrolls towards target position until reached\n     */\n    onTrackOngoingMousedown() {\n      const position = this.nextStep();\n      return this.scrollTo(position).pipe(takeWhile(() => !this.isReached(position)), switchMap(() => this.onTrackOngoingMousedown()));\n    }\n    /**\n     * Returns a flag that determines whether the scroll from the given position is the final step or not\n     */\n    isReached(position) {\n      if (this.scrollDirection === 'forward') {\n        return position >= this.scrollMax;\n      }\n      return position <= 0;\n    }\n    static #_ = this.ɵfac = function TrackAdapter_Factory(t) {\n      return new (t || TrackAdapter)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: TrackAdapter,\n      contentQueries: function TrackAdapter_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, ThumbAdapter, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.thumb = _t.first);\n        }\n      },\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return TrackAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TrackXDirective = /*#__PURE__*/(() => {\n  class TrackXDirective extends TrackAdapter {\n    get viewportScrollSize() {\n      return this.cmp.viewport.contentWidth;\n    }\n    constructor() {\n      effect(() => {\n        if (this.cmp.direction() === 'rtl') {\n          this.getCurrPosition = () => {\n            const offset = this.viewportScrollSize - this.viewportSize - this.control.viewportScrollOffset;\n            return offset * this.size / this.viewportScrollSize;\n          };\n          this.getScrollDirection = position => {\n            return position < this.getCurrPosition() ? 'forward' : 'backward';\n          };\n        } else {\n          this.getCurrPosition = () => {\n            return this.control.viewportScrollOffset * this.size / this.viewportScrollSize;\n          };\n          this.getScrollDirection = position => {\n            return position > this.getCurrPosition() ? 'forward' : 'backward';\n          };\n        }\n      });\n      super();\n      this.cssLengthProperty = '--track-x-length';\n    }\n    scrollTo(start) {\n      return fromPromise(this.cmp.scrollTo({\n        start,\n        duration: this.cmp.trackScrollDuration\n      }));\n    }\n    getScrollForwardStep() {\n      return this.control.viewportScrollOffset + this.viewportSize;\n    }\n    getScrollBackwardStep() {\n      return this.control.viewportScrollOffset - this.viewportSize;\n    }\n    static #_ = this.ɵfac = function TrackXDirective_Factory(t) {\n      return new (t || TrackXDirective)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: TrackXDirective,\n      selectors: [[\"\", \"scrollbarTrackX\", \"\"]],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: TrackAdapter,\n        useExisting: TrackXDirective\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return TrackXDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TrackYDirective = /*#__PURE__*/(() => {\n  class TrackYDirective extends TrackAdapter {\n    constructor() {\n      super(...arguments);\n      this.cssLengthProperty = '--track-y-length';\n    }\n    get viewportScrollSize() {\n      return this.cmp.viewport.contentHeight;\n    }\n    getCurrPosition() {\n      return this.control.viewportScrollOffset * this.size / this.viewportScrollSize;\n    }\n    getScrollDirection(position) {\n      return position > this.getCurrPosition() ? 'forward' : 'backward';\n    }\n    scrollTo(top) {\n      return fromPromise(this.cmp.scrollTo({\n        top,\n        duration: this.cmp.trackScrollDuration\n      }));\n    }\n    getScrollForwardStep() {\n      return this.control.viewportScrollOffset + this.viewportSize;\n    }\n    getScrollBackwardStep() {\n      return this.control.viewportScrollOffset - this.viewportSize;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵTrackYDirective_BaseFactory;\n      return function TrackYDirective_Factory(t) {\n        return (ɵTrackYDirective_BaseFactory || (ɵTrackYDirective_BaseFactory = i0.ɵɵgetInheritedFactory(TrackYDirective)))(t || TrackYDirective);\n      };\n    })();\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: TrackYDirective,\n      selectors: [[\"\", \"scrollbarTrackY\", \"\"]],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: TrackAdapter,\n        useExisting: TrackYDirective\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return TrackYDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ThumbXDirective = /*#__PURE__*/(() => {\n  class ThumbXDirective extends ThumbAdapter {\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵThumbXDirective_BaseFactory;\n      return function ThumbXDirective_Factory(t) {\n        return (ɵThumbXDirective_BaseFactory || (ɵThumbXDirective_BaseFactory = i0.ɵɵgetInheritedFactory(ThumbXDirective)))(t || ThumbXDirective);\n      };\n    })();\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: ThumbXDirective,\n      selectors: [[\"\", \"scrollbarThumbX\", \"\"]],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: ThumbAdapter,\n        useExisting: ThumbXDirective\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return ThumbXDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ThumbYDirective = /*#__PURE__*/(() => {\n  class ThumbYDirective extends ThumbAdapter {\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵThumbYDirective_BaseFactory;\n      return function ThumbYDirective_Factory(t) {\n        return (ɵThumbYDirective_BaseFactory || (ɵThumbYDirective_BaseFactory = i0.ɵɵgetInheritedFactory(ThumbYDirective)))(t || ThumbYDirective);\n      };\n    })();\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: ThumbYDirective,\n      selectors: [[\"\", \"scrollbarThumbY\", \"\"]],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: ThumbAdapter,\n        useExisting: ThumbYDirective\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return ThumbYDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ScrollbarButton = /*#__PURE__*/(() => {\n  class ScrollbarButton extends PointerEventsAdapter {\n    constructor() {\n      super(...arguments);\n      this.injector = inject(Injector);\n      this.afterFirstClickDelay = 120;\n      this.firstClickDuration = 100;\n      this.scrollBy = 50;\n      this.onGoingScrollBy = 12;\n      // canScroll function can work for y-axis and x-axis for both LTR and RTL directions\n      this.canScrollFunc = {\n        forward: (scrollOffset, scrollMax) => scrollOffset < scrollMax,\n        backward: scrollOffset => scrollOffset > 0\n      };\n      this.scrollStepFunc = {\n        forward: (scrollBy, offset) => offset + scrollBy,\n        backward: (scrollBy, offset) => offset - scrollBy\n      };\n      this.horizontalScrollStepFunc = {\n        rtl: {\n          forward: (scrollBy, offset, scrollMax) => scrollMax - offset - scrollBy,\n          backward: (scrollBy, offset, scrollMax) => scrollMax - offset + scrollBy\n        },\n        ltr: this.scrollStepFunc\n      };\n    }\n    get pointerEvents() {\n      const pointerDown$ = fromEvent(this.nativeElement, 'pointerdown').pipe(stopPropagation(), preventSelection(this.document));\n      const pointerUp$ = fromEvent(this.document, 'pointerup', {\n        passive: true\n      }).pipe(enableSelection(this.document));\n      const pointerLeave$ = fromEvent(this.nativeElement, 'pointerleave', {\n        passive: true\n      });\n      // Combine pointerup and pointerleave events into one stream\n      const pointerUpOrLeave$ = merge(pointerUp$, pointerLeave$);\n      return pointerDown$.pipe(switchMap(() => this.firstScrollStep().pipe(delay(this.afterFirstClickDelay), switchMap(() => this.onOngoingPointerdown()), takeUntil(pointerUpOrLeave$))));\n    }\n    ngOnInit() {\n      // Get the canScroll function according to scroll direction (forward/backward)\n      this.canScroll = this.canScrollFunc[this.scrollDirection];\n      if (this.control.axis === 'x') {\n        runInInjectionContext(this.injector, () => {\n          effect(() => {\n            const dir = this.cmp.direction();\n            // Get the nextStep function according to scroll direction (forward/backward) and layout direction (LTR/RTL)\n            this.nextStep = this.horizontalScrollStepFunc[dir][this.scrollDirection];\n          });\n        });\n      } else {\n        // Get the nextStep function according to scroll direction (forward/backward)\n        this.nextStep = this.scrollStepFunc[this.scrollDirection];\n      }\n    }\n    firstScrollStep() {\n      const value = this.nextStep(this.scrollBy, this.control.viewportScrollOffset, this.control.viewportScrollMax);\n      return this.control.scrollTo(value, this.firstClickDuration);\n    }\n    onGoingScrollStep() {\n      const scrollMax = this.control.viewportScrollMax;\n      const value = this.nextStep(this.onGoingScrollBy, this.control.viewportScrollOffset, scrollMax);\n      this.control.instantScrollTo(value, scrollMax);\n    }\n    onOngoingPointerdown() {\n      return interval(0, animationFrameScheduler).pipe(takeWhile(() => this.canScroll(this.control.viewportScrollOffset, this.control.viewportScrollMax)), tap(() => this.onGoingScrollStep()));\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵScrollbarButton_BaseFactory;\n      return function ScrollbarButton_Factory(t) {\n        return (ɵScrollbarButton_BaseFactory || (ɵScrollbarButton_BaseFactory = i0.ɵɵgetInheritedFactory(ScrollbarButton)))(t || ScrollbarButton);\n      };\n    })();\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: ScrollbarButton,\n      selectors: [[\"button\", \"scrollbarButton\", \"\"]],\n      inputs: {\n        scrollbarButton: \"scrollbarButton\",\n        scrollDirection: \"scrollDirection\"\n      },\n      standalone: true,\n      features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n      attrs: _c0,\n      decls: 3,\n      vars: 0,\n      consts: [[1, \"ng-scrollbar-button-icon\"], [\"width\", \"var(--scrollbar-button-size)\", \"height\", \"var(--scrollbar-button-size)\", \"viewBox\", \"0 0 512 512\", \"xmlns\", \"http://www.w3.org/2000/svg\"], [\"d\", \"M413.1,327.3l-1.8-2.1l-136-156.5c-4.6-5.3-11.5-8.6-19.2-8.6c-7.7,0-14.6,3.4-19.2,8.6L101,324.9l-2.3,2.6  C97,330,96,333,96,336.2c0,8.7,7.4,15.8,16.6,15.8v0h286.8v0c9.2,0,16.6-7.1,16.6-15.8C416,332.9,414.9,329.8,413.1,327.3z\"]],\n      template: function ScrollbarButton_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0);\n          i0.ɵɵnamespaceSVG();\n          i0.ɵɵelementStart(1, \"svg\", 1);\n          i0.ɵɵelement(2, \"path\", 2);\n          i0.ɵɵelementEnd()();\n        }\n      },\n      styles: [\"[_nghost-%COMP%]{--scrollbar-button-size: 20px;position:relative;border:none;margin:0;padding:0;border-radius:0;appearance:none;background-color:var(--scrollbar-button-color)}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{fill:var(--scrollbar-button-fill)}[_nghost-%COMP%]:hover{background:var(--scrollbar-button-hover-color)}[_nghost-%COMP%]:hover   svg[_ngcontent-%COMP%]{fill:var(--scrollbar-button-hover-fill)}[_nghost-%COMP%]:active{background:var(--scrollbar-button-active-color)}[_nghost-%COMP%]:active   svg[_ngcontent-%COMP%]{fill:var(--scrollbar-button-active-fill)}[scrollbarButton=top][_nghost-%COMP%], [scrollbarButton=start][_nghost-%COMP%]{order:1}[scrollbarButton=bottom][_nghost-%COMP%], [scrollbarButton=end][_nghost-%COMP%]{order:3}[scrollbarButton=top][_nghost-%COMP%], [scrollbarButton=bottom][_nghost-%COMP%]{width:100%;height:var(--scrollbar-button-size)}[scrollbarButton=start][_nghost-%COMP%], [scrollbarButton=end][_nghost-%COMP%]{width:var(--scrollbar-button-size);height:100%}[scrollbarButton=bottom][_nghost-%COMP%]{--_button-rotate: 180deg}[scrollbarButton=start][_nghost-%COMP%]{--_button-rotate: -90deg}[scrollbarButton=start][_nghost-%COMP%]   .ng-scrollbar-button-icon[_ngcontent-%COMP%]{writing-mode:vertical-lr}[scrollbarButton=end][_nghost-%COMP%]{--_button-rotate: 90deg}[scrollbarButton=end][_nghost-%COMP%]   .ng-scrollbar-button-icon[_ngcontent-%COMP%]{writing-mode:vertical-rl}.ng-scrollbar-button-icon[_ngcontent-%COMP%]{rotate:var(--_button-rotate);display:flex;place-content:center;place-items:center;width:100%;height:100%}\"],\n      changeDetection: 0\n    });\n  }\n  return ScrollbarButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ScrollbarY = /*#__PURE__*/(() => {\n  class ScrollbarY extends ScrollbarAdapter {\n    constructor() {\n      super(...arguments);\n      this.clientRectProperty = 'top';\n      this.sizeProperty = 'offsetHeight';\n      this.clientProperty = 'clientY';\n      this.offsetProperty = 'offsetY';\n      this.axis = 'y';\n    }\n    get viewportScrollMax() {\n      return this.cmp.viewport.scrollMaxY;\n    }\n    get viewportScrollOffset() {\n      return this.cmp.viewport.scrollTop;\n    }\n    scrollTo(top, duration) {\n      return fromPromise(this.cmp.scrollTo({\n        top,\n        duration\n      }));\n    }\n    instantScrollTo(value) {\n      this.cmp.viewport.scrollYTo(value);\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵScrollbarY_BaseFactory;\n      return function ScrollbarY_Factory(t) {\n        return (ɵScrollbarY_BaseFactory || (ɵScrollbarY_BaseFactory = i0.ɵɵgetInheritedFactory(ScrollbarY)))(t || ScrollbarY);\n      };\n    })();\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: ScrollbarY,\n      selectors: [[\"scrollbar-y\"]],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: SCROLLBAR_CONTROL,\n        useExisting: ScrollbarY\n      }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n      decls: 6,\n      vars: 7,\n      consts: [[\"sticky\", \"\"], [1, \"ng-scrollbar-sticky\"], [1, \"ng-scrollbar-track-wrapper\"], [\"scrollbarTrackY\", \"\"], [\"scrollbarThumbY\", \"\"], [\"scrollbarButton\", \"top\", \"scrollDirection\", \"backward\"], [\"scrollbarButton\", \"bottom\", \"scrollDirection\", \"forward\"]],\n      template: function ScrollbarY_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 1, 0)(2, \"div\", 2)(3, \"div\", 3);\n          i0.ɵɵelement(4, \"div\", 4);\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(5, ScrollbarY_Conditional_5_Template, 2, 6);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(3);\n          i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-track \", ctx.cmp.trackClass, \"\");\n          i0.ɵɵadvance();\n          i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-thumb \", ctx.cmp.thumbClass, \"\");\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(5, ctx.cmp.buttons() ? 5 : -1);\n        }\n      },\n      dependencies: [TrackYDirective, ThumbYDirective, ScrollbarButton],\n      styles: [\"[_nghost-%COMP%]{position:absolute;inset:0;pointer-events:none;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}.ng-scrollbar-sticky[_ngcontent-%COMP%]{top:calc(var(--_scrollbar-wrapper-top) * 1px);left:calc(var(--_scrollbar-wrapper-left) * 1px);right:calc(var(--_scrollbar-wrapper-right) * 1px);height:calc(var(--_scrollbar-wrapper-height) * 1px);width:calc(var(--_scrollbar-wrapper-width) * 1px);position:sticky;z-index:100;opacity:var(--_scrollbar-hover-opacity);transition:var(--_scrollbar-opacity-transition)}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]{touch-action:none;-webkit-user-select:none;user-select:none;top:var(--_scrollbar-track-top);bottom:var(--_scrollbar-track-bottom);right:var(--_scrollbar-track-right);left:var(--_scrollbar-track-left);pointer-events:var(--_scrollbar-pointer-events);transition:var(--scrollbar-track-wrapper-transition);position:absolute;overflow:hidden;display:flex;place-items:center}.ng-scrollbar-track[_ngcontent-%COMP%]{position:relative;width:100%;height:100%;background-color:var(--scrollbar-track-color);border-radius:var(--scrollbar-border-radius);cursor:default;z-index:1;order:2}.ng-scrollbar-thumb[_ngcontent-%COMP%]{box-sizing:border-box;position:absolute;transition:var(--scrollbar-thumb-transition);border-radius:var(--scrollbar-border-radius);height:var(--_thumb-height);width:var(--_thumb-width);animation-name:_ngcontent-%COMP%_scrollbarThumbAnimation;animation-duration:1ms;animation-timing-function:linear}@keyframes _ngcontent-%COMP%_scrollbarThumbAnimation{0%{translate:var(--_scrollbar-thumb-transform-from)}to{translate:var(--_scrollbar-thumb-transform-to)}}\", \"[_nghost-%COMP%]{--_scrollbar-wrapper-top: 0;--_scrollbar-wrapper-left: var(--_scrollbar-wrapper-y-left);--_scrollbar-wrapper-right: var(--_scrollbar-wrapper-y-right);--_scrollbar-wrapper-height: var(--viewport-height);--_scrollbar-wrapper-width: var(--_scrollbar-thickness);--_scrollbar-track-top: var(--_vertical-top);--_scrollbar-track-bottom: var(--_vertical-bottom);--_scrollbar-track-right: var(--_vertical-right);--_scrollbar-track-left: var(--_vertical-left);--_thumb-height: calc(var(--thumb-y-length) * 1px);--_thumb-width: 100%;--_scrollbar-thumb-transform-from: 0 0;--_scrollbar-thumb-transform-to: 0 calc(var(--_scrollbar-y-thumb-transform-to-value) * 1px)}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]{width:var(--_track-y-thickness);flex-direction:column}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]:hover{--_track-y-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-y-color: var(--scrollbar-thumb-hover-color)}.ng-scrollbar-thumb[_ngcontent-%COMP%]{animation-timeline:var(--_animation-timeline-y);min-height:calc(var(--scrollbar-thumb-min-size) * 1px);display:var(--_vertical-thumb-display);background-color:var(--_thumb-y-color)}\"],\n      changeDetection: 0\n    });\n  }\n  return ScrollbarY;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ScrollbarX = /*#__PURE__*/(() => {\n  class ScrollbarX extends ScrollbarAdapter {\n    get viewportScrollMax() {\n      return this.cmp.viewport.scrollMaxX;\n    }\n    get viewportScrollOffset() {\n      // Keep scrollLeft value positive for horizontal scrollbar\n      return Math.abs(this.cmp.viewport.scrollLeft);\n    }\n    constructor() {\n      effect(() => {\n        if (this.cmp.direction() === 'rtl') {\n          this.handlePosition = (position, scrollMax) => -(scrollMax - position);\n        } else {\n          this.handlePosition = position => position;\n        }\n      });\n      super();\n      this.manager = inject(ScrollbarManager);\n      this.clientRectProperty = 'left';\n      this.sizeProperty = 'offsetWidth';\n      this.clientProperty = 'clientX';\n      this.offsetProperty = 'offsetX';\n      this.axis = 'x';\n    }\n    scrollTo(left, duration) {\n      return fromPromise(this.cmp.scrollTo({\n        left,\n        duration\n      }));\n    }\n    instantScrollTo(value, scrollMax) {\n      this.cmp.viewport.scrollXTo(this.handlePosition(value, scrollMax));\n    }\n    static #_ = this.ɵfac = function ScrollbarX_Factory(t) {\n      return new (t || ScrollbarX)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: ScrollbarX,\n      selectors: [[\"scrollbar-x\"]],\n      hostVars: 1,\n      hostBindings: function ScrollbarX_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"dir\", ctx.cmp.direction());\n        }\n      },\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: SCROLLBAR_CONTROL,\n        useExisting: ScrollbarX\n      }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n      decls: 6,\n      vars: 7,\n      consts: [[\"sticky\", \"\"], [1, \"ng-scrollbar-sticky\"], [1, \"ng-scrollbar-track-wrapper\"], [\"scrollbarTrackX\", \"\"], [\"scrollbarThumbX\", \"\"], [\"scrollbarButton\", \"start\", \"scrollDirection\", \"backward\"], [\"scrollbarButton\", \"end\", \"scrollDirection\", \"forward\"]],\n      template: function ScrollbarX_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 1, 0)(2, \"div\", 2)(3, \"div\", 3);\n          i0.ɵɵelement(4, \"div\", 4);\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(5, ScrollbarX_Conditional_5_Template, 2, 6);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(3);\n          i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-track \", ctx.cmp.trackClass, \"\");\n          i0.ɵɵadvance();\n          i0.ɵɵclassMapInterpolate1(\"ng-scrollbar-thumb \", ctx.cmp.thumbClass, \"\");\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(5, ctx.cmp.buttons() ? 5 : -1);\n        }\n      },\n      dependencies: [TrackXDirective, ThumbXDirective, ScrollbarButton],\n      styles: [_c1, \"[_nghost-%COMP%]{--_scrollbar-wrapper-top: var(--_scrollbar-wrapper-x-top);--_scrollbar-wrapper-left: 0;--_scrollbar-wrapper-right: 0;--_scrollbar-wrapper-height: var(--_scrollbar-thickness);--_scrollbar-wrapper-width: var(--viewport-width);--_scrollbar-track-top: var(--_horizontal-top);--_scrollbar-track-bottom: var(--_horizontal-bottom);--_scrollbar-track-right: var(--_horizontal-right);--_scrollbar-track-left: var(--_horizontal-left);--_thumb-height: 100%;--_thumb-width: calc(var(--thumb-x-length) * 1px);--_scrollbar-thumb-transform-from: 0;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * 1px)}[_nghost-%COMP%]   .ng-scrollbar-button[scrollbarButton=start][_ngcontent-%COMP%]{_--button-rotate:90}[_nghost-%COMP%]   .ng-scrollbar-button[scrollbarButton=end][_ngcontent-%COMP%]{_--button-rotate:-90}[dir=rtl][_nghost-%COMP%]   .ng-scrollbar-thumb[_ngcontent-%COMP%]{animation-name:_ngcontent-%COMP%_scrollbarThumbRTLAnimation;will-change:right;--_scrollbar-thumb-transform-to: calc(var(--_scrollbar-x-thumb-transform-to-value) * -1px)}[dir=rtl][_nghost-%COMP%]   .ng-scrollbar-button[scrollbarButton=start][_ngcontent-%COMP%]{--_button-rotate: 90deg}[dir=rtl][_nghost-%COMP%]   .ng-scrollbar-button[scrollbarButton=end][_ngcontent-%COMP%]{--_button-rotate: -90deg}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]{height:var(--_track-x-thickness);flex-direction:row}.ng-scrollbar-track-wrapper[_ngcontent-%COMP%]:hover{--_track-x-thickness: var(--_scrollbar-hover-thickness-px);--_thumb-x-color: var(--scrollbar-thumb-hover-color)}.ng-scrollbar-thumb[_ngcontent-%COMP%]{animation-timeline:var(--_animation-timeline-x);min-width:calc(var(--scrollbar-thumb-min-size) * 1px);display:var(--_horizontal-thumb-display);background-color:var(--_thumb-x-color)}@keyframes _ngcontent-%COMP%_scrollbarThumbRTLAnimation{0%{right:var(--_scrollbar-thumb-transform-from)}to{right:calc(var(--_scrollbar-thumb-transform-to) * -1)}}\"],\n      changeDetection: 0\n    });\n  }\n  return ScrollbarX;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet Scrollbars = /*#__PURE__*/(() => {\n  class Scrollbars {\n    constructor() {\n      this.cmp = inject(NG_SCROLLBAR);\n    }\n    static #_ = this.ɵfac = function Scrollbars_Factory(t) {\n      return new (t || Scrollbars)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: Scrollbars,\n      selectors: [[\"scrollbars\"]],\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 2,\n      vars: 2,\n      template: function Scrollbars_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, Scrollbars_Conditional_0_Template, 1, 0, \"scrollbar-y\")(1, Scrollbars_Conditional_1_Template, 1, 0, \"scrollbar-x\");\n        }\n        if (rf & 2) {\n          i0.ɵɵconditional(0, ctx.cmp.verticalUsed() ? 0 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(1, ctx.cmp.horizontalUsed() ? 1 : -1);\n        }\n      },\n      dependencies: [ScrollbarX, ScrollbarY],\n      styles: [\"[_nghost-%COMP%]{display:contents}\"],\n      changeDetection: 0\n    });\n  }\n  return Scrollbars;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgScrollbar = /*#__PURE__*/(() => {\n  class NgScrollbar extends NgScrollbarCore {\n    ngOnInit() {\n      this.viewport.init(this.nativeElement, this.contentWrapper.nativeElement);\n      super.ngOnInit();\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgScrollbar_BaseFactory;\n      return function NgScrollbar_Factory(t) {\n        return (ɵNgScrollbar_BaseFactory || (ɵNgScrollbar_BaseFactory = i0.ɵɵgetInheritedFactory(NgScrollbar)))(t || NgScrollbar);\n      };\n    })();\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgScrollbar,\n      selectors: [[\"ng-scrollbar\", 3, \"externalViewport\", \"\"]],\n      viewQuery: function NgScrollbar_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c2, 7);\n          i0.ɵɵviewQuery(Scrollbars, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentWrapper = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._scrollbars = _t.first);\n        }\n      },\n      exportAs: [\"ngScrollbar\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_SCROLLBAR,\n        useExisting: NgScrollbar\n      }]), i0.ɵɵHostDirectivesFeature([ScrollViewport]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c3,\n      decls: 4,\n      vars: 0,\n      consts: [[\"contentWrapper\", \"\"]],\n      template: function NgScrollbar_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", null, 0);\n          i0.ɵɵprojection(2);\n          i0.ɵɵelement(3, \"scrollbars\");\n          i0.ɵɵelementEnd();\n        }\n      },\n      dependencies: [Scrollbars],\n      styles: [\"[_nghost-%COMP%]{display:block;position:relative;max-height:100%;max-width:100%;--scrollbar-border-radius: 0px;--scrollbar-thickness: 5;--scrollbar-offset: 0;--scrollbar-track-wrapper-transition: width 60ms linear, height 60ms linear;--scrollbar-track-color: transparent;--scrollbar-thumb-color: rgb(0 0 0 / 20%);--scrollbar-thumb-hover-color: var(--scrollbar-thumb-color);--scrollbar-hover-thickness: var(--scrollbar-thickness);--scrollbar-thumb-transition: none;--scrollbar-thumb-min-size: 20;--scrollbar-button-color: var(--scrollbar-thumb-color);--scrollbar-button-hover-color: var(--scrollbar-button-color);--scrollbar-button-active-color: var(--scrollbar-button-hover-color);--scrollbar-button-fill: white;--scrollbar-button-hover-fill: var(--scrollbar-button-fill);--scrollbar-button-active-fill: var(--scrollbar-button-hover-fill);--scrollbar-hover-opacity-transition-enter-duration: 0;--scrollbar-hover-opacity-transition-leave-duration: .4s;--scrollbar-hover-opacity-transition-leave-delay: 1s;--scrollbar-overscroll-behavior: initial;--scrollbar-mobile-overscroll-behavior: none;--_scrollbar-thickness: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 2);--_scrollbar-pointer-events: auto;--_scrollbar-offset-px: calc(var(--scrollbar-offset) * 1px);--_scrollbar-thickness-px: calc(var(--scrollbar-thickness) * 1px);--_scrollbar-hover-thickness-px: calc(var(--scrollbar-hover-thickness) * 1px);--_viewport-padding-top: 0;--_viewport-padding-bottom: 0;--_viewport-padding-left: 0;--_viewport-padding-right: 0;--_horizontal-thumb-display: block;--_vertical-thumb-display: block;--_viewport-overflow: auto;--_thumb-x-color: var(--scrollbar-thumb-color);--_thumb-y-color: var(--scrollbar-thumb-color);--_track-y-thickness: var(--_scrollbar-thickness-px);--_track-x-thickness: var(--_scrollbar-thickness-px);--_viewport-overscroll-behavior: var(--scrollbar-overscroll-behavior);--_scrollbar-content-width: fit-content}[_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-offset-px);--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-offset-px);--_horizontal-top: initial;--_horizontal-bottom: var(--_scrollbar-offset-px);--_scrollbar-wrapper-x-top: calc(var(--viewport-height) - var(--_scrollbar-thickness));--reached-offset: 1px;--reached-offset-top: var(--reached-offset);--reached-offset-bottom: var(--reached-offset);--reached-offset-start: var(--reached-offset);--reached-offset-end: var(--reached-offset);--dropped-offset: 1px;--dropped-offset-top: var(--dropped-offset);--dropped-offset-bottom: var(--dropped-offset);--dropped-offset-start: var(--dropped-offset);--dropped-offset-end: var(--dropped-offset);--_viewport_scroll-timeline: unset;--_animation-timeline-y: unset;--_scrollbar-y-thumb-transform-to-value: unset;--_scrollbar-x-thumb-transform-to-value: unset;--_scrollbar-thumb-transform-from: unset;--_scrollbar-thumb-transform-to: unset}.ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{min-height:100%;min-width:100%;height:100%;max-height:100%;max-width:100%}.ng-scroll-viewport[_nghost-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{position:relative;overflow:var(--_viewport-overflow);scroll-timeline:var(--_viewport_scroll-timeline);box-sizing:border-box!important;-webkit-overflow-scrolling:touch;will-change:scroll-position;-webkit-user-select:var(--_viewport-user-select);user-select:var(--_viewport-user-select);overscroll-behavior:var(--_viewport-overscroll-behavior)}.ng-scroll-viewport[_nghost-%COMP%] > .ng-scroll-content[_ngcontent-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport>.ng-scroll-content{width:var(--_scrollbar-content-width);z-index:1;min-width:100%;min-height:100%;contain:content;padding:var(--_viewport-padding-top, 0) var(--_viewport-padding-right, 0) var(--_viewport-padding-bottom, 0) var(--_viewport-padding-left, 0)}.ng-scroll-viewport[_nghost-%COMP%], .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport{scrollbar-width:none!important}.ng-scroll-viewport[_nghost-%COMP%]::-webkit-scrollbar, .ng-scrollbar-external-viewport[_nghost-%COMP%]     .ng-scroll-viewport::-webkit-scrollbar{display:none!important}[position=invertX][_nghost-%COMP%], [position=invertAll][_nghost-%COMP%]{--_horizontal-top: var(--_scrollbar-offset-px);--_horizontal-bottom: initial;--_scrollbar-wrapper-x-top: 0}[dir=ltr][_nghost-%COMP%]{--_scrollbar-wrapper-y-right: initial;--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-left: calc(var(--viewport-width) - var(--_scrollbar-thickness))}[dir=ltr][position=invertY][_nghost-%COMP%], [dir=ltr][position=invertAll][_nghost-%COMP%]{--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-left: 0}[dir=rtl][_nghost-%COMP%]{--_scrollbar-wrapper-y-left: initial;--_vertical-left: var(--_scrollbar-offset-px);--_vertical-right: initial;--_scrollbar-wrapper-y-right: calc(var(--viewport-width) - var(--_scrollbar-thickness))}[dir=rtl][position=invertY][_nghost-%COMP%], [dir=rtl][position=invertAll][_nghost-%COMP%]{--_vertical-right: var(--_scrollbar-offset-px);--_vertical-left: initial;--_scrollbar-wrapper-y-right: 0}[verticalUsed=true][horizontalUsed=true][_nghost-%COMP%]{--_scrollbar-thickness-margin: calc(var(--scrollbar-thickness) + var(--scrollbar-offset) * 3);--_scrollbar-thickness-margin-px: calc(var(--_scrollbar-thickness-margin) * 1px)}[horizontalUsed=true][_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-offset-px);--_vertical-bottom: var(--_scrollbar-thickness-margin-px)}[horizontalUsed=true][position=invertX][_nghost-%COMP%], [horizontalUsed=true][position=invertAll][_nghost-%COMP%]{--_vertical-top: var(--_scrollbar-thickness-margin-px);--_vertical-bottom: var(--_scrollbar-offset-px)}[verticalUsed=true][dir=ltr][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}[verticalUsed=true][dir=rtl][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}[verticalUsed=true][position=invertY][dir=ltr][_nghost-%COMP%], [verticalUsed=true][position=invertAll][dir=ltr][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-thickness-margin-px);--_horizontal-right: var(--_scrollbar-offset-px)}[verticalUsed=true][position=invertY][dir=rtl][_nghost-%COMP%], [verticalUsed=true][position=invertAll][dir=rtl][_nghost-%COMP%]{--_horizontal-left: var(--_scrollbar-offset-px);--_horizontal-right: var(--_scrollbar-thickness-margin-px)}[appearance=native][verticalUsed=true][dir=ltr][_nghost-%COMP%]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][verticalUsed=true][dir=rtl][_nghost-%COMP%]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}[appearance=native][verticalUsed=true][position=invertY][dir=ltr][_nghost-%COMP%], [appearance=native][verticalUsed=true][position=invertAll][dir=ltr][_nghost-%COMP%]{--_viewport-padding-left: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-right: 0}[appearance=native][verticalUsed=true][position=invertY][dir=rtl][_nghost-%COMP%], [appearance=native][verticalUsed=true][position=invertAll][dir=rtl][_nghost-%COMP%]{--_viewport-padding-left: 0;--_viewport-padding-right: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][horizontalUsed=true][_nghost-%COMP%]{--_viewport-padding-top: 0;--_viewport-padding-bottom: calc(var(--_scrollbar-thickness) * 1px)}[appearance=native][horizontalUsed=true][position=invertX][_nghost-%COMP%], [appearance=native][horizontalUsed=true][position=invertAll][_nghost-%COMP%]{--_viewport-padding-top: calc(var(--_scrollbar-thickness) * 1px);--_viewport-padding-bottom: 0}[visibility=hover][_nghost-%COMP%]{--_scrollbar-hover-opacity: 0;--_scrollbar-opacity-transition: opacity var(--scrollbar-hover-opacity-transition-leave-duration) var(--scrollbar-hover-opacity-transition-leave-delay)}[visibility=hover][_nghost-%COMP%]:hover, [visibility=hover][_nghost-%COMP%]:active, [visibility=hover][_nghost-%COMP%]:focus{--_scrollbar-hover-opacity: 1;--_scrollbar-opacity-transition: opacity var(--scrollbar-hover-opacity-transition-enter-duration)}[dir=ltr][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [dir=ltr][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=start]{left:0;right:unset}[dir=ltr][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end], [dir=ltr][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=end]{right:0;left:unset}[dir=rtl][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [dir=rtl][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=start]{right:0;left:unset}[dir=rtl][_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end], [dir=rtl][_nghost-%COMP%]     .scroll-dropped-trigger-element[trigger=end]{left:0;right:unset}[_nghost-%COMP%]     .ng-scroll-reached-wrapper, [_nghost-%COMP%]     .ng-scroll-dropped-wrapper, [_nghost-%COMP%]     .scroll-reached-trigger-element, [_nghost-%COMP%]     .scroll-dropped-trigger-element{position:absolute;-webkit-user-select:none;user-select:none;pointer-events:none;z-index:-9999}[_nghost-%COMP%]     .ng-scroll-reached-wrapper, [_nghost-%COMP%]     .ng-scroll-dropped-wrapper{visibility:hidden;inset:0;min-width:calc(var(--viewport-width) * 1px);min-height:calc(var(--viewport-height) * 1px)}[_nghost-%COMP%]     [isHorizontallyScrollable=false] .scroll-reached-trigger-element[trigger=end], [_nghost-%COMP%]     [isHorizontallyScrollable=false] .scroll-dropped-trigger-element[trigger=end]{display:none}[_nghost-%COMP%]     [isVerticallyScrollable=false] .scroll-reached-trigger-element[trigger=bottom], [_nghost-%COMP%]     [isVerticallyScrollable=false] .scroll-dropped-trigger-element[trigger=bottom]{display:none}[_nghost-%COMP%]     .scroll-reached-trigger-element{background:red}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=top], [_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=bottom]{left:0;right:0}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start], [_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end]{top:0;bottom:0}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=top]{top:0;height:var(--reached-offset-top)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=bottom]{bottom:0;height:var(--reached-offset-bottom)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=start]{width:var(--reached-offset-start)}[_nghost-%COMP%]     .scroll-reached-trigger-element[trigger=end]{width:var(--reached-offset-end)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[_ngcontent-%COMP%]{background:#00f}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=top][_ngcontent-%COMP%], [_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=bottom][_ngcontent-%COMP%]{left:0;right:0}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=start][_ngcontent-%COMP%], [_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=end][_ngcontent-%COMP%]{top:0;bottom:0}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=top][_ngcontent-%COMP%]{top:0;height:var(--dropped-offset-top)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=bottom][_ngcontent-%COMP%]{bottom:0;height:var(--dropped-offset-bottom)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=start][_ngcontent-%COMP%]{width:var(--dropped-offset-start)}[_nghost-%COMP%]   .scroll-dropped-trigger-element[trigger=end][_ngcontent-%COMP%]{width:var(--dropped-offset-end)}[verticalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerY;--_animation-timeline-y: --scrollerY;--_viewport_scroll-timeline: --scrollerY y;--_scrollbar-y-thumb-transform-to-value: calc(var(--track-y-length) - var(--thumb-y-length))}[horizontalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerX;--_animation-timeline-x: --scrollerX;--_viewport_scroll-timeline: --scrollerX x;--_scrollbar-x-thumb-transform-to-value: calc(var(--track-x-length) - var(--thumb-x-length))}[verticalUsed=true][horizontalUsed=true][_nghost-%COMP%]{--_timeline-scope: --scrollerX, --scrollerY;--_viewport_scroll-timeline: --scrollerX x, --scrollerY y}[orientation=vertical][_nghost-%COMP%]{--_viewport-overflow: hidden auto;--_scrollbar-content-width: unset}[orientation=horizontal][_nghost-%COMP%]{--_viewport-overflow: auto hidden}[disableInteraction=true][_nghost-%COMP%]{--_scrollbar-pointer-events: none}[isVerticallyScrollable=false][_nghost-%COMP%]{--_vertical-thumb-display: none}[isHorizontallyScrollable=false][_nghost-%COMP%]{--_horizontal-thumb-display: none}[dragging=x][_nghost-%COMP%], [dragging=y][_nghost-%COMP%]{--_viewport-user-select: none}[horizontalUsed=true][_nghost-%COMP%]{--thumb-x-length: max(calc(var(--viewport-width) * var(--track-x-length) / var(--content-width)), var(--scrollbar-thumb-min-size))}[verticalUsed=true][_nghost-%COMP%]{--thumb-y-length: max(calc(var(--viewport-height) * var(--track-y-length) / var(--content-height)), var(--scrollbar-thumb-min-size))}[dragging=x][_nghost-%COMP%]{--_track-x-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-x-color: var(--scrollbar-thumb-hover-color)}[dragging=y][_nghost-%COMP%]{--_track-y-thickness: calc(var(--scrollbar-hover-thickness) * 1px);--_thumb-y-color: var(--scrollbar-thumb-hover-color)}[mobile=true][_nghost-%COMP%]{--_viewport-overscroll-behavior: var(--scrollbar-mobile-overscroll-behavior)}\"],\n      changeDetection: 0\n    });\n  }\n  return NgScrollbar;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgScrollbarExt = /*#__PURE__*/(() => {\n  class NgScrollbarExt extends NgScrollbarCore {\n    constructor() {\n      super(...arguments);\n      this.renderer = inject(Renderer2);\n      this.appRef = inject(ApplicationRef);\n    }\n    ngOnInit() {\n      if (!this.skipInit) {\n        this.detectExternalSelectors();\n      }\n      super.ngOnInit();\n    }\n    detectExternalSelectors() {\n      let viewportElement;\n      if (this.customViewport) {\n        viewportElement = this.customViewport.nativeElement;\n      } else {\n        // If viewport selector was defined, query the element\n        if (this.externalViewport) {\n          viewportElement = this.nativeElement.querySelector(this.externalViewport);\n        }\n        if (!viewportElement) {\n          console.error(`[NgScrollbar]: Could not find the viewport element for the provided selector \"${this.externalViewport}\"`);\n          return;\n        }\n      }\n      // If an external spacer selector is provided, attempt to query for it\n      let spacerElement;\n      if (this.externalSpacer) {\n        spacerElement = this.nativeElement.querySelector(this.externalSpacer);\n        if (!spacerElement) {\n          console.error(`[NgScrollbar]: Spacer element not found for the provided selector \"${this.externalSpacer}\"`);\n          return;\n        }\n      }\n      // If an external content wrapper selector is provided, attempt to query for it\n      let contentWrapperElement;\n      if (this.externalContentWrapper && !this.skipInit) {\n        contentWrapperElement = this.nativeElement.querySelector(this.externalContentWrapper);\n        if (!contentWrapperElement) {\n          console.error(`[NgScrollbar]: Content wrapper element not found for the provided selector \"${this.externalContentWrapper}\"`);\n          return;\n        }\n      }\n      // Make sure viewport element is defined to proceed\n      if (viewportElement) {\n        // If no external spacer or content wrapper is provided, create a content wrapper element\n        if (!this.externalSpacer && !this.externalContentWrapper) {\n          contentWrapperElement = this.renderer.createElement('div');\n          // Move all content of the viewport into the content wrapper\n          const childNodes = Array.from(viewportElement.childNodes);\n          childNodes.forEach(node => this.renderer.appendChild(contentWrapperElement, node));\n          // Append the content wrapper to the viewport\n          this.renderer.appendChild(viewportElement, contentWrapperElement);\n        }\n        // Make sure content wrapper element is defined to proceed\n        if (contentWrapperElement) {\n          // Initialize viewport\n          this.viewport.init(viewportElement, contentWrapperElement, spacerElement);\n          // Attach scrollbars\n          this.attachScrollbars();\n        }\n      }\n    }\n    attachScrollbars() {\n      // Create the scrollbars component\n      const scrollbarsRef = createComponent(Scrollbars, {\n        environmentInjector: this.appRef.injector,\n        elementInjector: Injector.create({\n          providers: [{\n            provide: NG_SCROLLBAR,\n            useValue: this\n          }]\n        })\n      });\n      // Attach scrollbar to the content wrapper\n      this.viewport.contentWrapperElement.appendChild(scrollbarsRef.location.nativeElement);\n      // Attach the host view of the component to the main change detection tree, so that its lifecycle hooks run.\n      this.appRef.attachView(scrollbarsRef.hostView);\n      // Set the scrollbars instance\n      this._scrollbars = scrollbarsRef.instance;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgScrollbarExt_BaseFactory;\n      return function NgScrollbarExt_Factory(t) {\n        return (ɵNgScrollbarExt_BaseFactory || (ɵNgScrollbarExt_BaseFactory = i0.ɵɵgetInheritedFactory(NgScrollbarExt)))(t || NgScrollbarExt);\n      };\n    })();\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgScrollbarExt,\n      selectors: [[\"ng-scrollbar\", \"externalViewport\", \"\"]],\n      contentQueries: function NgScrollbarExt_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, ScrollViewport, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.customViewport = _t.first);\n        }\n      },\n      hostAttrs: [\"ngSkipHydration\", \"true\"],\n      hostVars: 2,\n      hostBindings: function NgScrollbarExt_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"ng-scrollbar-external-viewport\", true);\n        }\n      },\n      inputs: {\n        externalViewport: \"externalViewport\",\n        externalContentWrapper: \"externalContentWrapper\",\n        externalSpacer: \"externalSpacer\",\n        skipInit: [i0.ɵɵInputFlags.HasDecoratorInputTransform, \"skipInit\", \"skipInit\", booleanAttribute]\n      },\n      exportAs: [\"ngScrollbar\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_SCROLLBAR,\n        useExisting: NgScrollbarExt\n      }, {\n        provide: NgScrollbarCore,\n        useExisting: NgScrollbar\n      }]), i0.ɵɵInputTransformsFeature, i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature],\n      attrs: _c4,\n      ngContentSelectors: _c3,\n      decls: 1,\n      vars: 0,\n      template: function NgScrollbarExt_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      styles: [_c5],\n      changeDetection: 0\n    });\n  }\n  return NgScrollbarExt;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AsyncDetection = /*#__PURE__*/(() => {\n  class AsyncDetection {\n    constructor() {\n      this.scrollbar = inject(NgScrollbarExt);\n      this.zone = inject(NgZone);\n      this.scrollbar.skipInit = true;\n    }\n    ngOnInit() {\n      this.zone.runOutsideAngular(() => {\n        this.subscription = mutationObserver(this.scrollbar.nativeElement, 100).subscribe(() => {\n          if (!this.scrollbar.viewport.initialized()) {\n            // Search for external viewport\n            const viewportElement = this.scrollbar.nativeElement.querySelector(this.scrollbar.externalViewport);\n            // Search for external content wrapper\n            const contentWrapperElement = this.scrollbar.nativeElement.querySelector(this.scrollbar.externalContentWrapper);\n            if (viewportElement && contentWrapperElement) {\n              // If an external spacer selector is provided, search for it\n              let spacerElement;\n              if (this.scrollbar.externalSpacer) {\n                spacerElement = this.scrollbar.nativeElement.querySelector(this.scrollbar.externalSpacer);\n              }\n              // Initialize viewport\n              this.scrollbar.viewport.init(viewportElement, contentWrapperElement, spacerElement);\n              // Attach scrollbars\n              this.scrollbar.attachScrollbars();\n              if (!this.asyncDetection) {\n                this.subscription.unsubscribe();\n              }\n            }\n          } else {\n            const viewportElement = this.scrollbar.nativeElement.querySelector(this.scrollbar.externalViewport);\n            const contentWrapperElement = this.scrollbar.nativeElement.querySelector(this.scrollbar.externalContentWrapper);\n            if (!viewportElement || !contentWrapperElement) {\n              this.scrollbar.viewport.nativeElement = null;\n              this.scrollbar.viewport.contentWrapperElement = null;\n              this.scrollbar.viewport.initialized.set(false);\n            }\n          }\n        });\n      });\n    }\n    ngOnDestroy() {\n      this.subscription?.unsubscribe();\n    }\n    static #_ = this.ɵfac = function AsyncDetection_Factory(t) {\n      return new (t || AsyncDetection)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: AsyncDetection,\n      selectors: [[\"ng-scrollbar\", \"externalViewport\", \"\", \"asyncDetection\", \"\"]],\n      inputs: {\n        asyncDetection: \"asyncDetection\"\n      },\n      standalone: true\n    });\n  }\n  return AsyncDetection;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgScrollbarModule = /*#__PURE__*/(() => {\n  class NgScrollbarModule {\n    static #_ = this.ɵfac = function NgScrollbarModule_Factory(t) {\n      return new (t || NgScrollbarModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgScrollbarModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgScrollbarModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideScrollbarOptions(options) {\n  return [{\n    provide: NG_SCROLLBAR_OPTIONS,\n    useValue: options\n  }];\n}\nfunction provideScrollbarPolyfill(url) {\n  return [{\n    provide: NG_SCROLLBAR_POLYFILL,\n    useValue: url\n  }];\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AsyncDetection, NG_SCROLLBAR, NG_SCROLLBAR_OPTIONS, NG_SCROLLBAR_POLYFILL, NgScrollbar, NgScrollbarExt, NgScrollbarModule, ScrollViewport, ScrollbarUpdateReason, provideScrollbarOptions, provideScrollbarPolyfill };\n//# sourceMappingURL=ngx-scrollbar.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}